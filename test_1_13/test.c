#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
//自定义类型：结构体,枚举,联合1.1
//1.8 结构体传参
//struct S
//{
//	int data[1000];
//	int num;
//};
////结构体传参
//void print1(struct S s)
//{
//	printf("%d\n", s.num);
//}
////结构体地址传参
//void print2(const struct S* ps)
//{
//	printf("%d\n", ps->num);
//}
//int main()
//{
//	struct S s = { {1,2,3,4}, 1000 };
//	print1(s);  //传结构体
//	print2(&s); //传地址
//	return 0;
//}
//首选print2函数
//原因：函数传参的时候，参数是需要压栈，会有时间和空间上的系统开销。
//如果传递一个结构体对象的时候，结构体过大，参数压栈的的系统开销比较大，所以会导致性能的下降。
//结论：结构体传参的时候，要传结构体的地址



//2. 位段
//2.1 什么是位段	位指二进制位
//位段的声明和结构是类似的，有两个不同：
//1.位段的成员必须是 int、unsigned int 或signed int 。
//2.位段的成员名后边有一个冒号和一个数字。
 
 
//A就是一个位段类型。
//struct A
//{
//	int _a : 2;//2个bit位
//	int _b : 5;//5个bit位
//	int _c : 10;
//	int _d : 30;
//};
//int main()
//{
//	printf("%d\n", sizeof(struct A));//8个字节
//	return 0;
//}


//2.2 位段的内存分配
//1. 位段的成员可以是 int unsigned int signed int 或者是 char （属于整形家族）类型
//2. 位段的空间上是按照需要以4个字节（ int ）或者1个字节（ char ）的方式来开辟的。
//3. 位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段。

//一个例子
//struct S
//{
//	char a : 3;
//	char b : 4;
//	char c : 5;
//	char d : 4;
//};
//int main()
//{
//	struct S s = { 0 };
//	s.a = 10;	
//	s.b = 12;	
//	s.c = 3;
//	s.d = 4;
//	return 0;
//}

//2.3 位段的跨平台问题
//1. int 位段被当成有符号数还是无符号数是不确定的。
//2. 位段中最大位的数目不能确定。（16位机器最大16，32位机器最大32，写成27，在16位机器会出问题。
//3. 位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义。
//4. 当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的
//总结：跟结构相比，位段可以达到同样的效果，但是可以很好的节省空间，但是有跨平台的问题存在


//3. 枚举
//枚举顾名思义就是一一列举
//比如现实生活中：
//一周的星期一到星期日是有限的7天，可以一一列举。
//性别有：男、女、保密，也可以一一列举。
//月份有12个月，也可以一一列举
//enum Day ， enum Sex ， enum Color 都是枚举类型
//{}中的内容是枚举类型的可能取值，也叫枚举常量
//这些可能取值都是有值的，默认从0开始，一次递增1，当然在定义的时候也可以赋初值。

//enum Day//星期
//{
//	Mon,
//	Tues,
//	Wed,
//	Thur,
//	Fri,
//	Sat,
//	Sun
//};
//enum Sex//性别
//{
//	MALE,
//	FEMALE,
//	SECRET
//};
//enum Color//颜色
//{
//	RED=1,
//	GREEN=2,
//	BLUE=3
//};
//3.3 枚举的使用
//int main()
//{
//	printf("%d\n", sizeof(enum Color));//4个字节 枚举类型默认值0 1 2 为 int类型 
//	enum Color clr = GREEN;
//	//clr = 5;//err 两边类型不一致 左边为枚举类型 右边为整形
//	return 0;
//}
//3.2 枚举的优点
//1. 增加代码的可读性和可维护性
//2. 和#define定义的标识符比较枚举有类型检查，更加严谨。
//3. 防止了命名污染（封装）
//4. 便于调试
//5. 使用方便，一次可以定义多个常量



//4. 联合（共用体）
//4.1 联合类型的定义
//联合也是一种特殊的自定义类型
//这种类型定义的变量也包含一系列的成员，特征是这些成员公用同一块空间（所以联合也叫共用体）
//4.2 联合的特点
//联合的成员是共用同一块内存空间的，这样一个联合变量的大小，至少是最大成员的大小
//（因为联合至少得有能力保存最大的那个成员）
//union Un
//{
//	char c;
//	int i;
//};
//int main()
//{
//	union Un un;
//	//计算联合体变量的大小
//	printf("%d\n", sizeof(un));//4
//	// 下面输出的结果是一样的吗？
//	printf("%p\n", &(un.i));
//	printf("%p\n", &(un.c));
//	//下面输出的结果是什么？
//	un.i = 0x11223344;
//	un.c = 0x55;
//	printf("%x\n", un.i);//11223355
//	return 0;
//}


//面试题：判断当前计算机的大小端存储
//方法1
//int check_sys()
//{
//	int a = 1;
//	return *(char*)&a;
//}
// 方法2
//int check_sys()
//{
//	//匿名联合体
//	union 
//	{
//		int i;
//		char c;
//	}u;
//	u.i = 1;
//	return u.c;//返回1，表示小端	返回0，表示大端
//}
//int main()
//{
//	int ret = check_sys();
//	if (ret == 1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//	return 0;
//}



//4.3 联合大小的计算
//联合的大小至少是最大成员的大小。
//当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍
//union Un1
//{
//	char c[5];
//	int i;
//};
//union Un2
//{
//	short c[7];
//	int i;
//};
//int main()
//{
//	printf("%d\n", sizeof(union Un1));//8
//	printf("%d\n", sizeof(union Un2));//16
//	return 0;
//}